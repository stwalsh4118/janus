# [1-3] Implement POST /api/session/start endpoint

[Back to task list](./tasks.md)

## Description

Implement the session start endpoint that creates a new session, spawns a cursor-agent process with proper stdin/stdout pipes, and returns the session ID to the client. This integrates the SessionManager with actual cursor-agent process management.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-11 00:00:00 | Created | N/A | Proposed | Task file created | Sean |

## Requirements

1. Replace stub `POST /api/session/start` endpoint with full implementation
2. Create session using SessionManager
3. Spawn cursor-agent process with:
   - Proper working directory
   - Connected stdin/stdout pipes
   - Error handling for process spawn failures
4. Store process and pipes in Session struct
5. Return JSON response with session_id
6. Handle errors with consistent format:
   - Process spawn failures
   - Session creation failures
7. Add logging for session creation

## Implementation Plan

### 1. Update session handler
Modify `internal/api/handlers/session.go`:

```go
package handlers

import (
    "net/http"
    "os/exec"
    "path/filepath"

    "github.com/gin-gonic/gin"
    "github.com/sean/janus/internal/session"
)

type SessionHandler struct {
    manager session.Manager
    workDir string
}

func NewSessionHandler(manager session.Manager, workDir string) *SessionHandler {
    return &SessionHandler{
        manager: manager,
        workDir: workDir,
    }
}

type StartSessionResponse struct {
    SessionID string `json:"session_id"`
    Message   string `json:"message"`
}

func (h *SessionHandler) StartSession(c *gin.Context) {
    // Create session
    sess, err := h.manager.CreateSession()
    if err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "error": "Failed to create session",
            "details": err.Error(),
        })
        return
    }

    // Spawn cursor-agent process
    cmd := exec.Command("cursor-agent")
    cmd.Dir = h.workDir

    // Set up stdin
    stdin, err := cmd.StdinPipe()
    if err != nil {
        h.manager.EndSession(sess.ID)
        c.JSON(http.StatusInternalServerError, gin.H{
            "error": "Failed to create stdin pipe",
            "details": err.Error(),
        })
        return
    }

    // Set up stdout
    stdout, err := cmd.StdoutPipe()
    if err != nil {
        stdin.Close()
        h.manager.EndSession(sess.ID)
        c.JSON(http.StatusInternalServerError, gin.H{
            "error": "Failed to create stdout pipe",
            "details": err.Error(),
        })
        return
    }

    // Start the process
    if err := cmd.Start(); err != nil {
        stdin.Close()
        stdout.Close()
        h.manager.EndSession(sess.ID)
        c.JSON(http.StatusInternalServerError, gin.H{
            "error": "Failed to start cursor-agent process",
            "details": err.Error(),
        })
        return
    }

    // Update session with process info
    sess.Process = cmd
    sess.Stdin = stdin
    sess.Stdout = stdout

    c.JSON(http.StatusOK, StartSessionResponse{
        SessionID: sess.ID,
        Message:   "Session started successfully",
    })
}
```

### 2. Update router configuration
Modify `internal/api/router.go` to wire up the new handler:

```go
func SetupRouter(manager session.Manager, workDir string) *gin.Engine {
    router := gin.Default()

    // Middleware
    router.Use(cors.CORSMiddleware())

    // Handlers
    healthHandler := handlers.NewHealthHandler()
    sessionHandler := handlers.NewSessionHandler(manager, workDir)

    // Routes
    api := router.Group("/api")
    {
        api.GET("/health", healthHandler.Health)
        api.POST("/session/start", sessionHandler.StartSession)
        // ... other routes
    }

    return router
}
```

### 3. Update main.go
Modify `cmd/server/main.go` to pass workDir:

```go
// Initialize session manager
sessionManager := session.NewMemorySessionManager()

// Get workspace directory from config
workDir := cfg.WorkspaceDir // or os.Getwd() as fallback

// Setup router with dependencies
router := api.SetupRouter(sessionManager, workDir)
```

### 4. Add configuration for workspace directory
Update `internal/config/config.go`:

```go
type Config struct {
    Port         string
    WorkspaceDir string
}

func Load() (*Config, error) {
    return &Config{
        Port:         getEnv("PORT", "3000"),
        WorkspaceDir: getEnv("WORKSPACE_DIR", "."),
    }, nil
}
```

## Test Plan

### Unit Tests
Create `internal/api/handlers/session_test.go`:

1. **Test StartSession Success**:
   - Mock SessionManager
   - Verify session creation called
   - Verify 200 response with session_id

2. **Test StartSession - Manager Failure**:
   - Mock manager to return error
   - Verify 500 response with error message

3. **Test Process Spawn Handling**:
   - Test with invalid command (will fail in real env)
   - Verify proper cleanup on failure

### Integration Tests
Manual verification:

1. Start server with valid workspace
2. Call `POST /api/session/start`
3. Verify response contains valid UUID
4. Verify cursor-agent process running (ps aux | grep cursor-agent)
5. Call multiple times, verify unique session IDs
6. Verify each spawns separate process

### Success Criteria
- [ ] Endpoint creates session successfully
- [ ] Spawns cursor-agent process with correct working directory
- [ ] Returns valid session_id
- [ ] Process stdin/stdout pipes connected
- [ ] Error handling for process spawn failures
- [ ] Cleanup on failures (session removed if process fails)
- [ ] Multiple sessions can be created concurrently
- [ ] Consistent JSON error format

## Verification

```bash
# Start server
cd /home/sean/workspace/janus
air

# Test endpoint
curl -X POST http://localhost:3000/api/session/start

# Expected response:
# {"session_id":"<uuid>","message":"Session started successfully"}

# Verify process running
ps aux | grep cursor-agent

# Test concurrent creation
for i in {1..5}; do
  curl -X POST http://localhost:3000/api/session/start &
done
wait
```

## Files Modified

### Modified Files
- `internal/api/handlers/session.go`
- `internal/api/router.go`
- `cmd/server/main.go`
- `internal/config/config.go`

### New Files
- `internal/api/handlers/session_test.go`



