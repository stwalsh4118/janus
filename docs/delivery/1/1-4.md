# [1-4] Implement POST /api/ask endpoint

[Back to task list](./tasks.md)

## Description

Implement the question-handling endpoint that accepts user questions, sends them to the cursor-agent process, waits for responses with timeout, and returns the answer to the client. This task implements the core interaction loop with cursor-agent.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-11 00:00:00 | Created | N/A | Proposed | Task file created | Sean |
| 2025-10-11 16:30:00 | Status Change | Proposed | InProgress | Starting implementation with encapsulated communication methods | AI Agent |
| 2025-10-11 17:30:00 | Status Change | InProgress | Review | Implementation complete, all tests passing | AI Agent |
| 2025-10-11 18:00:00 | Status Change | Review | InProgress | Refactoring to use cursor-agent --print --resume approach | AI Agent |
| 2025-10-11 19:00:00 | Status Change | InProgress | Done | Migration complete, tested with live cursor-agent, context working | Sean |

## Requirements

1. Replace stub `POST /api/ask?session_id={id}` endpoint
2. Validate session_id parameter
3. Retrieve session from SessionManager
4. Write question to cursor-agent stdin
5. Read response from cursor-agent stdout
6. Implement 60-second timeout for responses
7. Update LastActivity timestamp
8. Append question and response to ConversationLog
9. Return JSON response with answer
10. Handle errors:
    - Invalid session_id
    - Session not found
    - Timeout waiting for response
    - Process communication errors

## Implementation Plan

### 1. Define request/response types
In `internal/api/handlers/session.go`:

```go
type AskRequest struct {
    Question string `json:"question" binding:"required"`
}

type AskResponse struct {
    Answer    string `json:"answer"`
    SessionID string `json:"session_id"`
}
```

### 2. Implement AskQuestion handler
```go
func (h *SessionHandler) AskQuestion(c *gin.Context) {
    sessionID := c.Query("session_id")
    if sessionID == "" {
        c.JSON(http.StatusBadRequest, gin.H{
            "error": "session_id query parameter is required",
        })
        return
    }

    var req AskRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, gin.H{
            "error": "Invalid request body",
            "details": err.Error(),
        })
        return
    }

    // Get session
    sess, err := h.manager.GetSession(sessionID)
    if err != nil {
        c.JSON(http.StatusNotFound, gin.H{
            "error": "Session not found",
            "details": err.Error(),
        })
        return
    }

    // Send question to cursor-agent
    questionMsg := fmt.Sprintf("%s\n", req.Question)
    if _, err := sess.Stdin.Write([]byte(questionMsg)); err != nil {
        c.JSON(http.StatusInternalServerError, gin.H{
            "error": "Failed to send question to cursor-agent",
            "details": err.Error(),
        })
        return
    }

    // Read response with timeout
    responseChan := make(chan string, 1)
    errorChan := make(chan error, 1)

    go func() {
        buf := make([]byte, 4096)
        n, err := sess.Stdout.Read(buf)
        if err != nil {
            errorChan <- err
            return
        }
        responseChan <- string(buf[:n])
    }()

    var answer string
    select {
    case answer = <-responseChan:
        // Success
    case err := <-errorChan:
        c.JSON(http.StatusInternalServerError, gin.H{
            "error": "Failed to read response from cursor-agent",
            "details": err.Error(),
        })
        return
    case <-time.After(session.CursorResponseTimeout):
        c.JSON(http.StatusRequestTimeout, gin.H{
            "error": "Timeout waiting for cursor-agent response",
        })
        return
    }

    // Update activity and conversation log
    now := time.Now()
    if err := h.manager.UpdateActivity(sessionID); err != nil {
        // Log error but don't fail the request
        fmt.Printf("Warning: failed to update activity for session %s: %v\n", sessionID, err)
    }

    sess.ConversationLog = append(sess.ConversationLog,
        session.Message{
            Role:      "user",
            Content:   req.Question,
            Timestamp: now,
        },
        session.Message{
            Role:      "assistant",
            Content:   answer,
            Timestamp: time.Now(),
        },
    )

    c.JSON(http.StatusOK, AskResponse{
        Answer:    answer,
        SessionID: sessionID,
    })
}
```

### 3. Update router
In `internal/api/router.go`:
```go
api.POST("/ask", sessionHandler.AskQuestion)
```

## Test Plan

### Unit Tests
In `internal/api/handlers/session_test.go`:

1. **Test AskQuestion Success**:
   - Mock session with working pipes
   - Verify question sent to stdin
   - Verify response read from stdout
   - Verify conversation log updated

2. **Test Missing session_id**:
   - Verify 400 response

3. **Test Invalid JSON body**:
   - Verify 400 response

4. **Test Session Not Found**:
   - Mock manager to return error
   - Verify 404 response

5. **Test Timeout**:
   - Mock slow response
   - Verify 408 response

### Integration Tests
Manual verification:

1. Start server and create session
2. Send question via API
3. Verify response received
4. Send multiple questions in same session
5. Verify conversation log accumulates
6. Test with different question types
7. Test timeout with blocking cursor command

### Success Criteria
- [x] Endpoint accepts questions and returns responses
- [x] Session validation working
- [x] Communication with cursor-agent successful
- [x] 60s timeout implemented (CursorResponseTimeout)
- [x] LastActivity timestamp updated
- [x] Conversation log maintained
- [x] Concurrent questions to different sessions work (thread-safe manager)
- [x] Error handling for all edge cases
- [x] Consistent JSON response format
- [x] Encapsulated communication methods added to Manager interface
- [x] All unit tests passing (41 sub-tests total)

## Verification

```bash
# Create session first
SESSION_ID=$(curl -X POST http://localhost:3000/api/session/start | jq -r '.session_id')

# Ask question
curl -X POST "http://localhost:3000/api/ask?session_id=$SESSION_ID" \
  -H "Content-Type: application/json" \
  -d '{"question":"What is the project structure?"}'

# Expected response:
# {"answer":"...","session_id":"<uuid>"}

# Ask follow-up question
curl -X POST "http://localhost:3000/api/ask?session_id=$SESSION_ID" \
  -H "Content-Type: application/json" \
  -d '{"question":"Tell me more about the backend"}'

# Test invalid session
curl -X POST "http://localhost:3000/api/ask?session_id=invalid" \
  -H "Content-Type: application/json" \
  -d '{"question":"test"}'
# Expected: 404 error
```

## Files Modified

### Modified Files
- `internal/session/interface.go` - Added SendQuestion, ReceiveAnswer, AddToConversationLog methods
- `internal/session/memory_manager.go` - Implemented communication methods with timeout support
- `internal/session/memory_manager_test.go` - Added tests for new communication methods
- `internal/api/handlers/session.go` - Implemented full Ask endpoint with cursor-agent communication
- `internal/api/handlers/session_test.go` - Updated tests with comprehensive Ask endpoint coverage



