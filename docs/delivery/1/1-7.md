# [1-7] Implement background session cleanup mechanism

[Back to task list](./tasks.md)

## Description

Implement a background goroutine that periodically checks for inactive sessions and automatically terminates them after the configured timeout period (10 minutes by default). This prevents resource leaks from abandoned sessions.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-11 00:00:00 | Created | N/A | Proposed | Task file created | Sean |
| 2025-10-11 14:00:00 | Status Change | Proposed | InProgress | Starting implementation - simplified for CLI architecture | AI Agent |
| 2025-10-11 14:30:00 | Status Change | InProgress | Review | Implementation complete - CleanupService created, tests passing, integrated with main.go | AI Agent |
| 2025-10-11 14:45:00 | Status Change | Review | Done | All tests passed, sync.Once added for double-stop protection | Sean |

## Requirements

1. Create background goroutine that runs continuously
2. Check for inactive sessions every 1 minute (configurable)
3. Remove sessions inactive for more than 10 minutes (configurable)
4. Call existing `CleanupInactiveSessions()` method on SessionManager
5. Support graceful shutdown of cleanup goroutine
6. Add logging for cleanup events
7. Use existing timeout configuration from config

**Note**: The current architecture uses cursor-agent as a CLI command per question (not a persistent process), so there are no processes or pipes to clean up. Session cleanup is simply removing inactive entries from the in-memory manager.

## Implementation Plan

### 1. Create cleanup service
Create `internal/session/cleanup.go`:

```go
package session

import (
    "context"
    "log"
    "time"
)

const (
    // DefaultCleanupInterval is how often to check for stale sessions
    DefaultCleanupInterval = 1 * time.Minute
)

// CleanupService manages automatic cleanup of inactive sessions
type CleanupService struct {
    manager  Manager
    timeout  time.Duration
    interval time.Duration
    ctx      context.Context
    cancel   context.CancelFunc
}

// NewCleanupService creates a new cleanup service
func NewCleanupService(manager Manager, timeout time.Duration, interval time.Duration) *CleanupService {
    ctx, cancel := context.WithCancel(context.Background())
    return &CleanupService{
        manager:  manager,
        timeout:  timeout,
        interval: interval,
        ctx:      ctx,
        cancel:   cancel,
    }
}

// Start begins the cleanup goroutine
func (s *CleanupService) Start() {
    log.Printf("Starting cleanup service (checking every %v, timeout %v)", s.interval, s.timeout)
    go s.run()
}

// Stop gracefully stops the cleanup goroutine
func (s *CleanupService) Stop() {
    log.Println("Stopping cleanup service...")
    s.cancel()
}

// run is the main cleanup loop
func (s *CleanupService) run() {
    ticker := time.NewTicker(s.interval)
    defer ticker.Stop()

    for {
        select {
        case <-s.ctx.Done():
            log.Println("Cleanup service stopped")
            return
        case <-ticker.C:
            s.cleanupInactiveSessions()
        }
    }
}

// cleanupInactiveSessions uses the manager's cleanup method to remove stale sessions
func (s *CleanupService) cleanupInactiveSessions() {
    // Get count before cleanup for logging
    sessionsBefore := len(s.manager.GetAllSessions())
    
    // Call the manager's cleanup method
    s.manager.CleanupInactiveSessions(s.timeout)
    
    // Get count after cleanup
    sessionsAfter := len(s.manager.GetAllSessions())
    
    if sessionsBefore != sessionsAfter {
        removed := sessionsBefore - sessionsAfter
        log.Printf("Cleanup: removed %d inactive session(s), %d active session(s) remaining", 
            removed, sessionsAfter)
    }
}
```

### 2. Update main.go to start cleanup service
In `cmd/server/main.go`, after creating the session manager:

```go
// Create session manager
sessionManager := session.NewMemorySessionManager()

// Start cleanup service
sessionTimeout := time.Duration(cfg.SessionTimeoutMinutes) * time.Minute
cleanupService := session.NewCleanupService(
    sessionManager,
    sessionTimeout,
    session.DefaultCleanupInterval,
)
cleanupService.Start()

// ... rest of server setup ...

// In the shutdown section, after receiving quit signal:
log.Println("Shutting down server...")

// Stop cleanup service
cleanupService.Stop()

// Shutdown server
ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()
if err := srv.Shutdown(ctx); err != nil {
    log.Fatal("Server forced to shutdown:", err)
}
```

**Note**: Configuration already has `SessionTimeoutMinutes` in the Config struct, so no config changes needed.

## Test Plan

### Unit Tests
Create `internal/session/cleanup_test.go`:

1. **Test CleanupService Creation**:
   - Verify service initializes correctly

2. **Test Cleanup Logic**:
   - Create sessions with different activity times
   - Run cleanup
   - Verify only stale sessions removed

3. **Test Graceful Shutdown**:
   - Start service
   - Call Stop()
   - Verify goroutine exits

4. **Test Process Termination**:
   - Mock session with process
   - Verify process killed
   - Verify pipes closed

### Integration Tests
Manual verification:

1. Start server
2. Create session
3. Wait 30 seconds
4. Verify session still active (send heartbeat)
5. Wait 11 minutes without heartbeat
6. Verify session automatically cleaned up
7. Check server logs for cleanup message
8. Verify cursor-agent process terminated
9. Create multiple sessions
10. Let some expire, keep others active
11. Verify only expired ones cleaned up

### Success Criteria
- [ ] Cleanup service starts with server
- [ ] Checks for stale sessions every minute
- [ ] Terminates sessions inactive for >10 minutes
- [ ] Processes gracefully shutdown
- [ ] Resources properly cleaned up
- [ ] Service stops gracefully on server shutdown
- [ ] Configurable timeout and interval
- [ ] Logging for cleanup events
- [ ] No impact on active sessions
- [ ] Thread-safe operation

## Verification

```bash
# Start server
cd /home/sean/workspace/janus
air

# Create test session
SESSION_ID=$(curl -X POST http://localhost:3000/api/session/start | jq -r '.session_id')

# Verify session active
curl -X POST "http://localhost:3000/api/heartbeat?session_id=$SESSION_ID"

# Wait 11 minutes (or adjust timeout for testing)
# Watch server logs for cleanup message

# After timeout, try to use session
curl -X POST "http://localhost:3000/api/heartbeat?session_id=$SESSION_ID"
# Expected: 404 error (session cleaned up)

# Verify process gone
ps aux | grep cursor-agent | grep -v grep
# Should not show process for this session

# Test with heartbeat keeping session alive
SESSION_ID=$(curl -X POST http://localhost:3000/api/session/start | jq -r '.session_id')
# Send heartbeat every 30 seconds for 15 minutes
for i in {1..30}; do
  curl -X POST "http://localhost:3000/api/heartbeat?session_id=$SESSION_ID"
  sleep 30
done
# Session should still be active
```

## Files Modified

### New Files
- `internal/session/cleanup.go` - CleanupService implementation with background goroutine
- `internal/session/cleanup_test.go` - Comprehensive tests for cleanup service

### Modified Files
- `cmd/server/main.go` - Initialize and start CleanupService, stop on graceful shutdown
- `docs/delivery/1/1-7.md` - Updated implementation plan to reflect CLI architecture
- `docs/delivery/1/tasks.md` - Updated task status to Review



