# [1-7] Implement background session cleanup mechanism

[Back to task list](./tasks.md)

## Description

Implement a background goroutine that periodically checks for inactive sessions and automatically terminates them after the configured timeout period (10 minutes by default). This prevents resource leaks from abandoned sessions.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-11 00:00:00 | Created | N/A | Proposed | Task file created | Sean |

## Requirements

1. Create background goroutine that runs continuously
2. Check for inactive sessions every 1 minute
3. Terminate sessions inactive for more than 10 minutes
4. Gracefully shutdown cursor-agent processes
5. Clean up resources (pipes, process)
6. Remove sessions from SessionManager
7. Support graceful shutdown of cleanup goroutine
8. Add logging for cleanup events
9. Make cleanup interval and timeout configurable

## Implementation Plan

### 1. Create cleanup service
Create `internal/session/cleanup.go`:

```go
package session

import (
    "context"
    "fmt"
    "os"
    "time"
)

const (
    // CleanupInterval is how often to check for stale sessions
    CleanupInterval = 1 * time.Minute
)

// CleanupService manages automatic cleanup of inactive sessions
type CleanupService struct {
    manager Manager
    timeout time.Duration
    ctx     context.Context
    cancel  context.CancelFunc
}

// NewCleanupService creates a new cleanup service
func NewCleanupService(manager Manager, timeout time.Duration) *CleanupService {
    ctx, cancel := context.WithCancel(context.Background())
    return &CleanupService{
        manager: manager,
        timeout: timeout,
        ctx:     ctx,
        cancel:  cancel,
    }
}

// Start begins the cleanup goroutine
func (s *CleanupService) Start() {
    go s.run()
}

// Stop gracefully stops the cleanup goroutine
func (s *CleanupService) Stop() {
    s.cancel()
}

// run is the main cleanup loop
func (s *CleanupService) run() {
    ticker := time.NewTicker(CleanupInterval)
    defer ticker.Stop()

    for {
        select {
        case <-s.ctx.Done():
            fmt.Println("Cleanup service stopped")
            return
        case <-ticker.C:
            s.cleanupInactiveSessions()
        }
    }
}

// cleanupInactiveSessions finds and terminates stale sessions
func (s *CleanupService) cleanupInactiveSessions() {
    sessions := s.manager.GetAllSessions()
    now := time.Now()

    for _, sess := range sessions {
        if now.Sub(sess.LastActivity) > s.timeout {
            fmt.Printf("Cleaning up inactive session: %s (inactive for %v)\n",
                sess.ID, now.Sub(sess.LastActivity))

            // Terminate process
            s.terminateSession(sess)

            // Remove from manager
            if err := s.manager.EndSession(sess.ID); err != nil {
                fmt.Printf("Error removing session %s: %v\n", sess.ID, err)
            }
        }
    }
}

// terminateSession gracefully shuts down a session's process
func (s *CleanupService) terminateSession(sess *Session) {
    // Close pipes
    if sess.Stdin != nil {
        sess.Stdin.Close()
    }
    if sess.Stdout != nil {
        sess.Stdout.Close()
    }

    // Terminate process
    if sess.Process != nil {
        // Try graceful shutdown
        if err := sess.Process.Process.Signal(os.Interrupt); err != nil {
            // Force kill if interrupt fails
            sess.Process.Process.Kill()
        }

        // Wait for exit with timeout
        done := make(chan error, 1)
        go func() {
            done <- sess.Process.Wait()
        }()

        select {
        case <-done:
            // Process exited
        case <-time.After(5 * time.Second):
            // Timeout, force kill
            sess.Process.Process.Kill()
            <-done
        }
    }
}
```

### 2. Update main.go to start cleanup service
In `cmd/server/main.go`:

```go
func main() {
    // ... existing setup ...

    // Initialize session manager
    sessionManager := session.NewMemorySessionManager()

    // Start cleanup service
    cleanupService := session.NewCleanupService(
        sessionManager,
        session.DefaultSessionTimeout,
    )
    cleanupService.Start()
    defer cleanupService.Stop()

    // ... rest of server setup ...

    // Graceful shutdown
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
    <-quit

    fmt.Println("Shutting down server...")

    // Stop cleanup service
    cleanupService.Stop()

    // Shutdown server
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    if err := srv.Shutdown(ctx); err != nil {
        log.Fatal("Server forced to shutdown:", err)
    }

    fmt.Println("Server exited")
}
```

### 3. Add configuration for cleanup settings
In `internal/config/config.go`:

```go
type Config struct {
    Port                string
    WorkspaceDir        string
    SessionTimeout      time.Duration
    CleanupInterval     time.Duration
}

func Load() (*Config, error) {
    sessionTimeout, _ := time.ParseDuration(getEnv("SESSION_TIMEOUT", "10m"))
    cleanupInterval, _ := time.ParseDuration(getEnv("CLEANUP_INTERVAL", "1m"))

    return &Config{
        Port:            getEnv("PORT", "3000"),
        WorkspaceDir:    getEnv("WORKSPACE_DIR", "."),
        SessionTimeout:  sessionTimeout,
        CleanupInterval: cleanupInterval,
    }, nil
}
```

## Test Plan

### Unit Tests
Create `internal/session/cleanup_test.go`:

1. **Test CleanupService Creation**:
   - Verify service initializes correctly

2. **Test Cleanup Logic**:
   - Create sessions with different activity times
   - Run cleanup
   - Verify only stale sessions removed

3. **Test Graceful Shutdown**:
   - Start service
   - Call Stop()
   - Verify goroutine exits

4. **Test Process Termination**:
   - Mock session with process
   - Verify process killed
   - Verify pipes closed

### Integration Tests
Manual verification:

1. Start server
2. Create session
3. Wait 30 seconds
4. Verify session still active (send heartbeat)
5. Wait 11 minutes without heartbeat
6. Verify session automatically cleaned up
7. Check server logs for cleanup message
8. Verify cursor-agent process terminated
9. Create multiple sessions
10. Let some expire, keep others active
11. Verify only expired ones cleaned up

### Success Criteria
- [ ] Cleanup service starts with server
- [ ] Checks for stale sessions every minute
- [ ] Terminates sessions inactive for >10 minutes
- [ ] Processes gracefully shutdown
- [ ] Resources properly cleaned up
- [ ] Service stops gracefully on server shutdown
- [ ] Configurable timeout and interval
- [ ] Logging for cleanup events
- [ ] No impact on active sessions
- [ ] Thread-safe operation

## Verification

```bash
# Start server
cd /home/sean/workspace/janus
air

# Create test session
SESSION_ID=$(curl -X POST http://localhost:3000/api/session/start | jq -r '.session_id')

# Verify session active
curl -X POST "http://localhost:3000/api/heartbeat?session_id=$SESSION_ID"

# Wait 11 minutes (or adjust timeout for testing)
# Watch server logs for cleanup message

# After timeout, try to use session
curl -X POST "http://localhost:3000/api/heartbeat?session_id=$SESSION_ID"
# Expected: 404 error (session cleaned up)

# Verify process gone
ps aux | grep cursor-agent | grep -v grep
# Should not show process for this session

# Test with heartbeat keeping session alive
SESSION_ID=$(curl -X POST http://localhost:3000/api/session/start | jq -r '.session_id')
# Send heartbeat every 30 seconds for 15 minutes
for i in {1..30}; do
  curl -X POST "http://localhost:3000/api/heartbeat?session_id=$SESSION_ID"
  sleep 30
done
# Session should still be active
```

## Files Modified

### New Files
- `internal/session/cleanup.go`
- `internal/session/cleanup_test.go`

### Modified Files
- `cmd/server/main.go`
- `internal/config/config.go`



