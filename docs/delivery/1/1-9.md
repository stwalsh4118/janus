# [1-9] Add comprehensive error handling and request timeouts

[Back to task list](./tasks.md)

## Description

Implement comprehensive error handling across all endpoints with consistent JSON error responses, proper HTTP status codes, and request-level timeouts. This task ensures robust error handling and prevents hanging requests.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-11 00:00:00 | Created | N/A | Proposed | Task file created | Sean |

## Requirements

1. Define consistent error response format
2. Implement proper HTTP status codes for all error cases
3. Add request timeout middleware (60s default)
4. Add panic recovery middleware
5. Improve error messages to be client-friendly
6. Add request ID tracking for debugging
7. Log all errors with context
8. Handle cursor-agent process crashes gracefully

## Implementation Plan

### 1. Define error response types
Create `internal/api/errors.go`:

```go
package api

import (
    "github.com/gin-gonic/gin"
    "net/http"
)

// ErrorResponse is the standard error response format
type ErrorResponse struct {
    Error     string `json:"error"`
    Details   string `json:"details,omitempty"`
    RequestID string `json:"request_id,omitempty"`
    Timestamp string `json:"timestamp"`
}

// Error codes
const (
    ErrSessionNotFound       = "SESSION_NOT_FOUND"
    ErrInvalidSessionID      = "INVALID_SESSION_ID"
    ErrInvalidRequest        = "INVALID_REQUEST"
    ErrProcessSpawnFailed    = "PROCESS_SPAWN_FAILED"
    ErrProcessCommunication  = "PROCESS_COMMUNICATION_FAILED"
    ErrTimeout               = "REQUEST_TIMEOUT"
    ErrInternalServer        = "INTERNAL_SERVER_ERROR"
)

// RespondWithError sends a standardized error response
func RespondWithError(c *gin.Context, status int, errorCode string, details string) {
    requestID, _ := c.Get("request_id")
    c.JSON(status, ErrorResponse{
        Error:     errorCode,
        Details:   details,
        RequestID: requestID.(string),
        Timestamp: time.Now().Format(time.RFC3339),
    })
}
```

### 2. Create middleware for request handling
Create `internal/api/middleware/request.go`:

```go
package middleware

import (
    "context"
    "fmt"
    "time"

    "github.com/gin-gonic/gin"
    "github.com/google/uuid"
)

const (
    // DefaultRequestTimeout is the maximum time for a request
    DefaultRequestTimeout = 60 * time.Second
)

// RequestID middleware adds a unique ID to each request
func RequestID() gin.HandlerFunc {
    return func(c *gin.Context) {
        requestID := uuid.New().String()
        c.Set("request_id", requestID)
        c.Header("X-Request-ID", requestID)
        c.Next()
    }
}

// RequestTimeout middleware enforces request timeout
func RequestTimeout(timeout time.Duration) gin.HandlerFunc {
    return func(c *gin.Context) {
        ctx, cancel := context.WithTimeout(c.Request.Context(), timeout)
        defer cancel()

        c.Request = c.Request.WithContext(ctx)

        finished := make(chan struct{})
        go func() {
            c.Next()
            finished <- struct{}{}
        }()

        select {
        case <-finished:
            return
        case <-ctx.Done():
            if ctx.Err() == context.DeadlineExceeded {
                c.JSON(http.StatusRequestTimeout, gin.H{
                    "error": "Request timeout",
                    "request_id": c.GetString("request_id"),
                })
                c.Abort()
            }
        }
    }
}

// Recovery middleware recovers from panics
func Recovery() gin.HandlerFunc {
    return func(c *gin.Context) {
        defer func() {
            if err := recover(); err != nil {
                requestID := c.GetString("request_id")
                fmt.Printf("Panic recovered [%s]: %v\n", requestID, err)

                c.JSON(http.StatusInternalServerError, gin.H{
                    "error": "Internal server error",
                    "request_id": requestID,
                })
                c.Abort()
            }
        }()
        c.Next()
    }
}

// Logger middleware logs all requests
func Logger() gin.HandlerFunc {
    return func(c *gin.Context) {
        start := time.Now()
        requestID := c.GetString("request_id")

        c.Next()

        duration := time.Since(start)
        fmt.Printf("[%s] %s %s - %d (%v)\n",
            requestID,
            c.Request.Method,
            c.Request.URL.Path,
            c.Writer.Status(),
            duration,
        )
    }
}
```

### 3. Update router to use middleware
Modify `internal/api/router.go`:

```go
func SetupRouter(manager session.Manager, workDir string, version string) *gin.Engine {
    // Use custom mode for production
    gin.SetMode(gin.ReleaseMode)
    
    router := gin.New()

    // Apply middleware in order
    router.Use(middleware.Recovery())
    router.Use(middleware.RequestID())
    router.Use(middleware.Logger())
    router.Use(middleware.RequestTimeout(middleware.DefaultRequestTimeout))
    router.Use(cors.CORSMiddleware())

    // Handlers
    healthHandler := handlers.NewHealthHandler(version, manager)
    sessionHandler := handlers.NewSessionHandler(manager, workDir)

    // Routes
    api := router.Group("/api")
    {
        api.GET("/health", healthHandler.Health)
        api.POST("/session/start", sessionHandler.StartSession)
        api.POST("/ask", sessionHandler.AskQuestion)
        api.POST("/session/end", sessionHandler.EndSession)
        api.POST("/heartbeat", sessionHandler.Heartbeat)
    }

    return router
}
```

### 4. Update handlers to use consistent error responses
Modify all handlers in `internal/api/handlers/session.go` to use `api.RespondWithError`:

Example for StartSession:
```go
func (h *SessionHandler) StartSession(c *gin.Context) {
    sess, err := h.manager.CreateSession()
    if err != nil {
        api.RespondWithError(c, http.StatusInternalServerError, 
            api.ErrInternalServer, "Failed to create session")
        return
    }
    
    // ... rest of implementation
}
```

### 5. Add process crash detection
In session manager, add method to detect crashed processes:

```go
// IsProcessAlive checks if the cursor-agent process is still running
func (s *Session) IsProcessAlive() bool {
    if s.Process == nil || s.Process.Process == nil {
        return false
    }
    
    // Check if process is still running
    err := s.Process.Process.Signal(syscall.Signal(0))
    return err == nil
}
```

## Test Plan

### Unit Tests
Create `internal/api/middleware/request_test.go`:

1. **Test RequestID Middleware**:
   - Verify unique ID generated
   - Verify header set correctly

2. **Test RequestTimeout Middleware**:
   - Test request completes within timeout
   - Test request exceeds timeout
   - Verify 408 response on timeout

3. **Test Recovery Middleware**:
   - Trigger panic in handler
   - Verify recovery occurs
   - Verify 500 response

4. **Test Logger Middleware**:
   - Verify logging format
   - Verify duration calculated

### Integration Tests
Manual verification:

1. Test error responses for all endpoints
2. Verify consistent error format
3. Test request timeout with long-running operation
4. Trigger panic and verify recovery
5. Verify request IDs in logs
6. Test cursor-agent crash handling
7. Verify all error messages are user-friendly

### Success Criteria
- [ ] Consistent error response format across all endpoints
- [ ] Proper HTTP status codes for all error cases
- [ ] Request timeout middleware working
- [ ] Panic recovery prevents server crashes
- [ ] Request ID tracking functional
- [ ] All errors logged with context
- [ ] Process crash detection working
- [ ] User-friendly error messages
- [ ] No information leakage in errors

## Verification

```bash
# Test error responses
curl -X POST http://localhost:3000/api/ask
# Expected: 400 with consistent error format

# Test timeout (if possible to simulate)
curl -X POST http://localhost:3000/api/ask?session_id=test \
  -H "Content-Type: application/json" \
  -d '{"question":"very long query..."}'

# Test invalid session
curl -X POST "http://localhost:3000/api/heartbeat?session_id=invalid"
# Expected: 404 with error format including request_id

# Verify request ID in headers
curl -i http://localhost:3000/api/health
# Should see X-Request-ID header

# Test rapid requests (verify timeout doesn't affect normal requests)
for i in {1..10}; do
  curl http://localhost:3000/api/health &
done
wait

# Kill cursor-agent process manually and try to use session
SESSION_ID=$(curl -X POST http://localhost:3000/api/session/start | jq -r '.session_id')
# Find and kill the process
pkill -f "cursor-agent"
# Try to ask question
curl -X POST "http://localhost:3000/api/ask?session_id=$SESSION_ID" \
  -H "Content-Type: application/json" \
  -d '{"question":"test"}'
# Should handle gracefully with error
```

## Files Modified

### New Files
- `internal/api/errors.go`
- `internal/api/middleware/request.go`
- `internal/api/middleware/request_test.go`

### Modified Files
- `internal/api/router.go`
- `internal/api/handlers/session.go`
- `internal/session/types.go` (add IsProcessAlive method)



