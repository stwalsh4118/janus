# [1-10] E2E CoS Test - Verify session management

[Back to task list](./tasks.md)

## Description

Implement end-to-end testing that verifies all Conditions of Satisfaction for PBI-1 are met. This comprehensive test validates the complete session management functionality from session creation through cleanup.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-11 00:00:00 | Created | N/A | Proposed | Task file created | Sean |

## Requirements

Verify all acceptance criteria from PBI-1:
1. Server starts successfully and listens on configured port
2. POST /api/session/start creates a new session and returns session_id
3. POST /api/ask accepts questions and returns responses from cursor-agent
4. Sessions are isolated - questions in one session don't affect others
5. POST /api/heartbeat updates LastActivity timestamp
6. Background cleanup terminates sessions inactive for >10 minutes
7. POST /api/session/end gracefully terminates session and cleans up resources
8. GET /api/health returns server status and active session count
9. Invalid session IDs return 404 with clear error message
10. Server handles process crashes gracefully without crashing itself
11. Request timeouts are implemented (60s for cursor responses)
12. All API responses follow consistent JSON format

## Implementation Plan

### 1. Create E2E test structure
Create `test/e2e/session_management_test.go`:

```go
package e2e

import (
    "bytes"
    "encoding/json"
    "fmt"
    "io"
    "net/http"
    "testing"
    "time"

    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

const baseURL = "http://localhost:3000"

// Test helper functions
func makeRequest(t *testing.T, method, path string, body interface{}) (*http.Response, []byte) {
    var reqBody io.Reader
    if body != nil {
        jsonBody, err := json.Marshal(body)
        require.NoError(t, err)
        reqBody = bytes.NewBuffer(jsonBody)
    }

    req, err := http.NewRequest(method, baseURL+path, reqBody)
    require.NoError(t, err)

    if body != nil {
        req.Header.Set("Content-Type", "application/json")
    }

    client := &http.Client{Timeout: 65 * time.Second}
    resp, err := client.Do(req)
    require.NoError(t, err)

    respBody, err := io.ReadAll(resp.Body)
    require.NoError(t, err)
    resp.Body.Close()

    return resp, respBody
}

// CoS 1: Server starts successfully
func TestServerHealth(t *testing.T) {
    resp, body := makeRequest(t, "GET", "/api/health", nil)
    assert.Equal(t, http.StatusOK, resp.StatusCode)

    var health map[string]interface{}
    err := json.Unmarshal(body, &health)
    require.NoError(t, err)

    assert.Equal(t, "healthy", health["status"])
    assert.Contains(t, health, "version")
    assert.Contains(t, health, "uptime")
    assert.Contains(t, health, "active_sessions")
}

// CoS 2: Session creation
func TestSessionCreation(t *testing.T) {
    resp, body := makeRequest(t, "POST", "/api/session/start", nil)
    assert.Equal(t, http.StatusOK, resp.StatusCode)

    var result map[string]interface{}
    err := json.Unmarshal(body, &result)
    require.NoError(t, err)

    assert.Contains(t, result, "session_id")
    assert.NotEmpty(t, result["session_id"])

    // Verify session_id is a valid UUID format
    sessionID := result["session_id"].(string)
    assert.Len(t, sessionID, 36) // UUID format
}

// CoS 3 & 4: Question handling and session isolation
func TestQuestionHandlingAndIsolation(t *testing.T) {
    // Create two sessions
    resp1, body1 := makeRequest(t, "POST", "/api/session/start", nil)
    require.Equal(t, http.StatusOK, resp1.StatusCode)
    var session1 map[string]interface{}
    json.Unmarshal(body1, &session1)
    sessionID1 := session1["session_id"].(string)

    resp2, body2 := makeRequest(t, "POST", "/api/session/start", nil)
    require.Equal(t, http.StatusOK, resp2.StatusCode)
    var session2 map[string]interface{}
    json.Unmarshal(body2, &session2)
    sessionID2 := session2["session_id"].(string)

    // Ask question in session 1
    question1 := map[string]string{"question": "What is the project structure?"}
    resp, body := makeRequest(t, "POST", 
        fmt.Sprintf("/api/ask?session_id=%s", sessionID1), question1)
    assert.Equal(t, http.StatusOK, resp.StatusCode)

    var answer1 map[string]interface{}
    json.Unmarshal(body, &answer1)
    assert.Contains(t, answer1, "answer")
    assert.NotEmpty(t, answer1["answer"])

    // Ask different question in session 2
    question2 := map[string]string{"question": "What is the backend tech stack?"}
    resp, body = makeRequest(t, "POST", 
        fmt.Sprintf("/api/ask?session_id=%s", sessionID2), question2)
    assert.Equal(t, http.StatusOK, resp.StatusCode)

    var answer2 map[string]interface{}
    json.Unmarshal(body, &answer2)
    assert.Contains(t, answer2, "answer")

    // Cleanup
    makeRequest(t, "POST", fmt.Sprintf("/api/session/end?session_id=%s", sessionID1), nil)
    makeRequest(t, "POST", fmt.Sprintf("/api/session/end?session_id=%s", sessionID2), nil)
}

// CoS 5: Heartbeat updates activity
func TestHeartbeat(t *testing.T) {
    // Create session
    resp, body := makeRequest(t, "POST", "/api/session/start", nil)
    require.Equal(t, http.StatusOK, resp.StatusCode)
    var session map[string]interface{}
    json.Unmarshal(body, &session)
    sessionID := session["session_id"].(string)

    // Send heartbeat
    resp, body = makeRequest(t, "POST", 
        fmt.Sprintf("/api/heartbeat?session_id=%s", sessionID), nil)
    assert.Equal(t, http.StatusOK, resp.StatusCode)

    var heartbeat map[string]interface{}
    json.Unmarshal(body, &heartbeat)
    assert.Contains(t, heartbeat, "last_activity")
    assert.Equal(t, sessionID, heartbeat["session_id"])

    // Cleanup
    makeRequest(t, "POST", fmt.Sprintf("/api/session/end?session_id=%s", sessionID), nil)
}

// CoS 7: Session termination
func TestSessionTermination(t *testing.T) {
    // Create session
    resp, body := makeRequest(t, "POST", "/api/session/start", nil)
    require.Equal(t, http.StatusOK, resp.StatusCode)
    var session map[string]interface{}
    json.Unmarshal(body, &session)
    sessionID := session["session_id"].(string)

    // End session
    resp, body = makeRequest(t, "POST", 
        fmt.Sprintf("/api/session/end?session_id=%s", sessionID), nil)
    assert.Equal(t, http.StatusOK, resp.StatusCode)

    var result map[string]interface{}
    json.Unmarshal(body, &result)
    assert.Contains(t, result, "message")

    // Verify session no longer exists
    resp, _ = makeRequest(t, "POST", 
        fmt.Sprintf("/api/heartbeat?session_id=%s", sessionID), nil)
    assert.Equal(t, http.StatusNotFound, resp.StatusCode)
}

// CoS 8: Health endpoint with session count
func TestHealthWithSessionCount(t *testing.T) {
    // Get initial health
    resp, body := makeRequest(t, "GET", "/api/health", nil)
    var health1 map[string]interface{}
    json.Unmarshal(body, &health1)
    initialCount := int(health1["active_sessions"].(float64))

    // Create 3 sessions
    sessions := make([]string, 3)
    for i := 0; i < 3; i++ {
        resp, body := makeRequest(t, "POST", "/api/session/start", nil)
        var session map[string]interface{}
        json.Unmarshal(body, &session)
        sessions[i] = session["session_id"].(string)
    }

    // Check health again
    resp, body = makeRequest(t, "GET", "/api/health", nil)
    var health2 map[string]interface{}
    json.Unmarshal(body, &health2)
    newCount := int(health2["active_sessions"].(float64))

    assert.Equal(t, initialCount+3, newCount)

    // Cleanup
    for _, sessionID := range sessions {
        makeRequest(t, "POST", fmt.Sprintf("/api/session/end?session_id=%s", sessionID), nil)
    }
}

// CoS 9: Invalid session ID handling
func TestInvalidSessionID(t *testing.T) {
    resp, body := makeRequest(t, "POST", 
        "/api/heartbeat?session_id=invalid-session", nil)
    assert.Equal(t, http.StatusNotFound, resp.StatusCode)

    var errorResp map[string]interface{}
    json.Unmarshal(body, &errorResp)
    assert.Contains(t, errorResp, "error")
}

// CoS 12: Consistent JSON format
func TestConsistentJSONFormat(t *testing.T) {
    // Test all endpoints return valid JSON
    endpoints := []struct {
        method string
        path   string
        body   interface{}
    }{
        {"GET", "/api/health", nil},
        {"POST", "/api/session/start", nil},
    }

    for _, ep := range endpoints {
        resp, body := makeRequest(t, ep.method, ep.path, ep.body)
        assert.True(t, resp.StatusCode >= 200 && resp.StatusCode < 300)

        var result map[string]interface{}
        err := json.Unmarshal(body, &result)
        assert.NoError(t, err, "Response should be valid JSON")
    }
}
```

### 2. Create test runner script
Create `test/e2e/run_tests.sh`:

```bash
#!/bin/bash

# Start server in background
cd /home/sean/workspace/janus
air &
SERVER_PID=$!

# Wait for server to be ready
echo "Waiting for server to start..."
sleep 5

# Run tests
go test ./test/e2e -v

# Capture test result
TEST_RESULT=$?

# Cleanup
kill $SERVER_PID

exit $TEST_RESULT
```

### 3. Add test documentation
Create `test/e2e/README.md`:

```markdown
# E2E Tests for Session Management

## Running Tests

### Automated
```bash
./test/e2e/run_tests.sh
```

### Manual
1. Start server: `air`
2. Run tests: `go test ./test/e2e -v`

## Test Coverage

See task 1-10 documentation for complete CoS coverage matrix.
```

## Test Plan

This task IS the test plan for PBI-1. The success criteria are the passing of all tests defined in this task.

### Manual Verification Steps

1. **Server Startup**:
   ```bash
   air
   # Verify no errors, server listening
   ```

2. **Session Creation**:
   ```bash
   curl -X POST http://localhost:3000/api/session/start
   ```

3. **Question Handling**:
   ```bash
   SESSION_ID=<id>
   curl -X POST "http://localhost:3000/api/ask?session_id=$SESSION_ID" \
     -H "Content-Type: application/json" \
     -d '{"question":"test"}'
   ```

4. **Session Isolation**:
   - Create 2 sessions
   - Ask different questions in each
   - Verify separate contexts

5. **Heartbeat**:
   ```bash
   curl -X POST "http://localhost:3000/api/heartbeat?session_id=$SESSION_ID"
   ```

6. **Background Cleanup**:
   - Create session
   - Wait 11 minutes
   - Verify session removed

7. **Session Termination**:
   ```bash
   curl -X POST "http://localhost:3000/api/session/end?session_id=$SESSION_ID"
   ```

8. **Health Check**:
   ```bash
   curl http://localhost:3000/api/health
   ```

9. **Error Handling**:
   ```bash
   curl -X POST "http://localhost:3000/api/heartbeat?session_id=invalid"
   ```

10. **Process Crash Handling**:
    - Create session
    - Kill cursor-agent process
    - Attempt to use session
    - Verify graceful error

### Success Criteria
- [ ] All automated E2E tests pass
- [ ] Manual verification steps complete successfully
- [ ] All 12 CoS from PBI-1 verified
- [ ] No memory leaks observed
- [ ] No resource leaks observed
- [ ] Server remains stable under test load
- [ ] Error messages are clear and consistent

## Verification

```bash
# Run automated tests
./test/e2e/run_tests.sh

# Expected output:
# === RUN TestServerHealth
# --- PASS: TestServerHealth (0.01s)
# === RUN TestSessionCreation
# --- PASS: TestSessionCreation (0.05s)
# ... (all tests pass)
# PASS
# ok      github.com/sean/janus/test/e2e  10.234s

# Run with verbose output
go test ./test/e2e -v

# Run specific test
go test ./test/e2e -run TestSessionCreation -v
```

## Files Modified

### New Files
- `test/e2e/session_management_test.go`
- `test/e2e/run_tests.sh`
- `test/e2e/README.md`



