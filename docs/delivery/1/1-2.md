# [1-2] Implement SessionManager with thread-safe operations

[Back to task list](./tasks.md)

## Description

Implement the SessionManager interface with in-memory session storage using a map and mutex for thread-safe concurrent operations. This task provides the core session management functionality without integrating cursor-agent processes yet.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-11 00:00:00 | Created | N/A | Proposed | Task file created | Sean |

## Requirements

1. Implement `SessionManager` interface from task 1-1
2. Use map[string]*Session for in-memory storage
3. Implement mutex-based locking for thread safety
4. Generate UUIDs for session IDs
5. Implement all Manager interface methods:
   - CreateSession() - generates ID, initializes session
   - GetSession(id) - retrieves session by ID (with deep copy to prevent data races)
   - UpdateActivity(id) - updates LastActivity timestamp
   - EndSession(id) - removes session from map
   - GetAllSessions() - returns all active sessions (with deep copies to prevent data races)
   - CleanupInactiveSessions(timeout) - removes stale sessions

6. Proper error handling for:
   - Session not found
   - Duplicate session attempts

7. **Address CodeRabbit findings from task 1-1**:
   - Implement deep copying in GetSession to prevent external mutations
   - Implement deep copying in GetAllSessions to prevent external mutations
   - Consider adding Session.Clone() method for cleaner implementation

## Implementation Plan

### 1. Install UUID dependency
```bash
go get github.com/google/uuid
```

### 2. Implement SessionManager
Create `internal/session/memory_manager.go`:

```go
package session

import (
    "fmt"
    "sync"
    "time"

    "github.com/google/uuid"
)

// MemorySessionManager implements Manager interface with in-memory storage
type MemorySessionManager struct {
    sessions map[string]*Session
    mu       sync.RWMutex
}

// NewMemorySessionManager creates a new in-memory session manager
func NewMemorySessionManager() *MemorySessionManager {
    return &MemorySessionManager{
        sessions: make(map[string]*Session),
    }
}

// CreateSession creates a new session with a unique ID
func (m *MemorySessionManager) CreateSession() (*Session, error) {
    m.mu.Lock()
    defer m.mu.Unlock()

    sessionID := uuid.New().String()
    now := time.Now()

    session := &Session{
        ID:              sessionID,
        CreatedAt:       now,
        LastActivity:    now,
        ConversationLog: make([]Message, 0),
    }

    m.sessions[sessionID] = session
    return session, nil
}

// GetSession retrieves a session by ID
func (m *MemorySessionManager) GetSession(id string) (*Session, error) {
    m.mu.RLock()
    defer m.mu.RUnlock()

    session, exists := m.sessions[id]
    if !exists {
        return nil, fmt.Errorf("session not found: %s", id)
    }

    return session, nil
}

// UpdateActivity updates the LastActivity timestamp for a session
func (m *MemorySessionManager) UpdateActivity(id string) error {
    m.mu.Lock()
    defer m.mu.Unlock()

    session, exists := m.sessions[id]
    if !exists {
        return fmt.Errorf("session not found: %s", id)
    }

    session.LastActivity = time.Now()
    return nil
}

// EndSession removes a session from the manager
func (m *MemorySessionManager) EndSession(id string) error {
    m.mu.Lock()
    defer m.mu.Unlock()

    if _, exists := m.sessions[id]; !exists {
        return fmt.Errorf("session not found: %s", id)
    }

    delete(m.sessions, id)
    return nil
}

// GetAllSessions returns all active sessions
func (m *MemorySessionManager) GetAllSessions() []*Session {
    m.mu.RLock()
    defer m.mu.RUnlock()

    sessions := make([]*Session, 0, len(m.sessions))
    for _, session := range m.sessions {
        sessions = append(sessions, session)
    }

    return sessions
}

// CleanupInactiveSessions removes sessions inactive for longer than timeout
func (m *MemorySessionManager) CleanupInactiveSessions(timeout time.Duration) {
    m.mu.Lock()
    defer m.mu.Unlock()

    now := time.Now()
    for id, session := range m.sessions {
        if now.Sub(session.LastActivity) > timeout {
            delete(m.sessions, id)
        }
    }
}
```

## Test Plan

### Unit Tests
Create `internal/session/memory_manager_test.go`:

1. **Test CreateSession**:
   - Creates session with valid UUID
   - Initializes timestamps correctly
   - Returns unique IDs for multiple sessions

2. **Test GetSession**:
   - Returns correct session by ID
   - Returns error for non-existent ID

3. **Test UpdateActivity**:
   - Updates LastActivity timestamp
   - Returns error for invalid session ID

4. **Test EndSession**:
   - Removes session from map
   - Returns error for non-existent session

5. **Test GetAllSessions**:
   - Returns all active sessions
   - Returns empty slice when no sessions

6. **Test CleanupInactiveSessions**:
   - Removes sessions older than timeout
   - Keeps active sessions
   - Handles empty session map

7. **Test Thread Safety**:
   - Concurrent CreateSession calls
   - Concurrent read/write operations

### Success Criteria
- [ ] All interface methods implemented
- [ ] Thread-safe operations with proper mutex usage
- [ ] UUID generation working
- [ ] All unit tests passing
- [ ] Code compiles without errors
- [ ] Proper error handling for edge cases

## Verification

```bash
# Run unit tests
cd /home/sean/workspace/janus
go test ./internal/session -v

# Run with race detector
go test ./internal/session -race

# Verify compilation
go build ./internal/session/...
```

## Files Modified

### New Files
- `internal/session/memory_manager.go`
- `internal/session/memory_manager_test.go`



