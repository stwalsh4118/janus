# [4-7] Implement comprehensive error handling and fallbacks

[Back to task list](./tasks.md)

## Description

Implement comprehensive error handling throughout the app including network failures, API errors, browser compatibility issues, permission denials, and session timeouts. Add user-friendly error messages and recovery options.

## Status History

| Timestamp | Event Type | From Status | To Status | Details | User |
|-----------|------------|-------------|-----------|---------|------|
| 2025-10-12 00:00:00 | Created | N/A | Proposed | Task file created | Sean |

## Requirements

1. Handle Speech Recognition errors:
   - Browser not supported → show text input fallback
   - Permission denied → show instructions and retry
   - Network error → show error message
   - No speech detected → prompt user

2. Handle Speech Synthesis errors:
   - No voices available → continue without TTS
   - Playback failed → show error but don't block

3. Handle API errors:
   - Network timeout → auto-retry once
   - Session not found → create new session
   - Backend down → show reconnection UI
   - Rate limiting → show wait message

4. Handle Session errors:
   - Session expired → auto-reconnect
   - Connection lost → heartbeat recovery
   - Multiple failed heartbeats → force new session

## Implementation Plan

### 1. Create ErrorDisplay Component
```typescript
// web/components/ErrorDisplay.tsx
"use client";

import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Button } from "@/components/ui/button";
import { AlertCircle, RefreshCw, X } from "lucide-react";

interface ErrorDisplayProps {
  error: string;
  onRetry?: () => void;
  onDismiss?: () => void;
  canRetry?: boolean;
}

export function ErrorDisplay({ 
  error, 
  onRetry, 
  onDismiss,
  canRetry = true 
}: ErrorDisplayProps) {
  return (
    <Alert variant="destructive" className="relative">
      <AlertCircle className="h-4 w-4" />
      <AlertTitle>Error</AlertTitle>
      <AlertDescription className="mt-2">
        {error}
      </AlertDescription>
      
      <div className="flex gap-2 mt-4">
        {canRetry && onRetry && (
          <Button 
            variant="outline" 
            size="sm" 
            onClick={onRetry}
            className="gap-2"
          >
            <RefreshCw className="h-3 w-3" />
            Retry
          </Button>
        )}
        {onDismiss && (
          <Button 
            variant="ghost" 
            size="sm" 
            onClick={onDismiss}
          >
            <X className="h-3 w-3" />
            Dismiss
          </Button>
        )}
      </div>
    </Alert>
  );
}
```

### 2. Create TextInputFallback Component
```typescript
// web/components/TextInputFallback.tsx
"use client";

import { useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Send } from "lucide-react";

interface TextInputFallbackProps {
  onSubmit: (question: string) => void;
  disabled?: boolean;
}

export function TextInputFallback({ onSubmit, disabled }: TextInputFallbackProps) {
  const [question, setQuestion] = useState("");

  const handleSubmit = (e: React.FormEvent) => {
    e.preventDefault();
    if (question.trim()) {
      onSubmit(question);
      setQuestion("");
    }
  };

  return (
    <Card className="border-yellow-500">
      <CardHeader>
        <CardTitle className="text-sm">Text Input (Voice Not Available)</CardTitle>
      </CardHeader>
      <CardContent>
        <form onSubmit={handleSubmit} className="flex gap-2">
          <Input
            value={question}
            onChange={(e) => setQuestion(e.target.value)}
            placeholder="Type your question..."
            disabled={disabled}
            className="flex-1"
          />
          <Button 
            type="submit" 
            disabled={disabled || !question.trim()}
            size="icon"
          >
            <Send className="h-4 w-4" />
          </Button>
        </form>
      </CardContent>
    </Card>
  );
}
```

### 3. Add Error Recovery in page.tsx
```typescript
// web/app/page.tsx
const [consecutiveErrors, setConsecutiveErrors] = useState(0);
const [lastError, setLastError] = useState<string | null>(null);

const MAX_RETRIES = 3;
const RETRY_DELAY = 2000;

const handleApiError = async (error: unknown, retryFn: () => Promise<void>) => {
  const errorMessage = error instanceof Error ? error.message : 'Unknown error';
  setLastError(errorMessage);
  setConsecutiveErrors(prev => prev + 1);

  // Auto-retry once after delay
  if (consecutiveErrors < MAX_RETRIES) {
    setTimeout(async () => {
      try {
        await retryFn();
        setConsecutiveErrors(0);
        setLastError(null);
      } catch (retryError) {
        console.error('Retry failed:', retryError);
      }
    }, RETRY_DELAY);
  }
};

const handleSessionLost = async () => {
  setStatus("connecting");
  try {
    const newSessionId = await apiClient.startSession();
    setSessionId(newSessionId);
    setStatus("connected");
    setLastError(null);
    setConsecutiveErrors(0);
  } catch (err) {
    setStatus("disconnected");
    setLastError("Failed to reconnect. Please refresh the page.");
  }
};

const handleReleaseToTalk = async () => {
  stopListening();
  
  if (!sessionId || !transcript) return;

  setIsProcessing(true);
  try {
    const answer = await apiClient.ask(sessionId, transcript);
    // ... success handling
    setConsecutiveErrors(0);
    setLastError(null);
  } catch (err) {
    if (err instanceof Error && err.message.includes('SESSION_NOT_FOUND')) {
      await handleSessionLost();
      // Retry the question
      if (sessionId) {
        await handleReleaseToTalk();
      }
    } else {
      await handleApiError(err, () => handleReleaseToTalk());
    }
  } finally {
    setIsProcessing(false);
  }
};

// Enhanced heartbeat with error recovery
useEffect(() => {
  if (!sessionId) return;

  let failedHeartbeats = 0;

  const sendHeartbeat = async () => {
    try {
      await apiClient.heartbeat(sessionId);
      failedHeartbeats = 0;
    } catch (err) {
      failedHeartbeats++;
      console.error(`Heartbeat failed (${failedHeartbeats}/3):`, err);

      if (failedHeartbeats >= 3) {
        // Session is likely dead, try to reconnect
        await handleSessionLost();
      }
    }
  };

  const interval = setInterval(sendHeartbeat, 30000);
  return () => clearInterval(interval);
}, [sessionId]);
```

### 4. Add Permission Request UI
```typescript
// web/components/PermissionRequest.tsx
"use client";

import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Button } from "@/components/ui/button";
import { Mic } from "lucide-react";

interface PermissionRequestProps {
  onRequest: () => void;
}

export function PermissionRequest({ onRequest }: PermissionRequestProps) {
  return (
    <Alert>
      <Mic className="h-4 w-4" />
      <AlertTitle>Microphone Access Required</AlertTitle>
      <AlertDescription className="mt-2">
        This app needs access to your microphone to recognize speech.
        Click the button below to grant permission.
      </AlertDescription>
      <Button onClick={onRequest} className="mt-4">
        Grant Microphone Access
      </Button>
    </Alert>
  );
}
```

### 5. Update page.tsx to Show Fallbacks
```typescript
// web/app/page.tsx
return (
  <main className="min-h-screen bg-background flex flex-col">
    {/* Fixed Header */}
    <div className="flex-shrink-0 p-4 space-y-4">
      <StatusIndicator
        status={status}
        version={healthData?.version}
        activeSessions={healthData?.active_sessions}
      />

      {/* Error Display */}
      {lastError && (
        <ErrorDisplay
          error={lastError}
          onRetry={consecutiveErrors < MAX_RETRIES ? handleRetry : undefined}
          onDismiss={() => setLastError(null)}
          canRetry={consecutiveErrors < MAX_RETRIES}
        />
      )}

      {/* Speech Recognition Not Supported */}
      {!speechRecognitionSupported && (
        <TextInputFallback
          onSubmit={(q) => {
            // Handle text question
            const userMessage = { id: uuidv4(), role: "user", content: q, timestamp: new Date() };
            setMessages(prev => [...prev, userMessage]);
            // Send to API...
          }}
          disabled={!sessionId}
        />
      )}
    </div>

    {/* Conversation History */}
    <ConversationHistory
      messages={messages}
      currentTranscript={transcript + interimTranscript}
      onPlayMessage={handlePlayMessage}
    />

    {/* Push-to-Talk or Fallback */}
    <div className="flex-shrink-0 flex justify-center py-4 border-t bg-background">
      {speechRecognitionSupported ? (
        <PushToTalk
          disabled={status !== "connected" || !sessionId}
          isListening={isListening}
          isProcessing={isProcessing}
          isSpeaking={isSpeaking}
          error={speechError}
          onPress={handlePressToTalk}
          onRelease={handleReleaseToTalk}
        />
      ) : (
        <p className="text-sm text-muted-foreground">
          Use text input above to ask questions
        </p>
      )}
    </div>
  </main>
);
```

## Test Plan

### Success Criteria

- [ ] Text input fallback appears when speech not supported
- [ ] Permission denied shows helpful instructions
- [ ] API errors auto-retry once after 2 seconds
- [ ] Session timeout triggers automatic reconnection
- [ ] 3 consecutive heartbeat failures trigger reconnection
- [ ] Network errors show clear error message with retry button
- [ ] Backend down shows reconnection UI
- [ ] User can dismiss non-critical errors
- [ ] Critical errors block interactions appropriately
- [ ] All error states have recovery paths

### Manual Testing

1. **Browser Compatibility**:
   - Test in Firefox (no speech support)
   - Verify text input appears
   - Verify can still ask questions

2. **Permission Denial**:
   - Deny microphone permission
   - Verify error message
   - Grant permission
   - Verify recovery

3. **Network Errors**:
   - Stop backend server
   - Try to ask question
   - Verify error and auto-retry
   - Start server
   - Verify reconnection

4. **Session Timeout**:
   - Wait 11 minutes (past session timeout)
   - Try to ask question
   - Verify new session created

## Verification

```bash
cd /home/sean/workspace/janus/web
pnpm dev

# Test scenarios:
# 1. Open in Firefox - verify fallback
# 2. Deny microphone - verify error
# 3. Stop backend - verify reconnection
# 4. Simulate slow network - verify timeout handling
```

## Files Modified

### New Files
- `web/components/ErrorDisplay.tsx` - Generic error display with retry
- `web/components/TextInputFallback.tsx` - Text input for unsupported browsers
- `web/components/PermissionRequest.tsx` - Microphone permission request UI

### Modified Files
- `web/app/page.tsx` - Add comprehensive error handling
- `web/lib/api-client.ts` - Better error types and messages
- `web/components/ui/input.tsx` - Add if missing from shadcn


